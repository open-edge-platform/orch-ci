---
# SPDX-FileCopyrightText: (C) 2026 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

# yamllint disable rule:line-length

name: Post-Merge CI Pipeline

on:  # yamllint disable-line rule:truthy
  workflow_call:
    inputs:
      run_version_check:
        description: "Run version check"
        required: false
        default: false
        type: boolean
      run_dep_version_check:
        description: "Run dependency version check"
        required: false
        default: false
        type: boolean
      run_freeup_ubuntu_space:
        description: "Freeup space in runner by removing unwanted packages"
        required: false
        default: false
        type: boolean
      run_build:
        description: "Run build via make build call"
        required: false
        default: true
        type: boolean
      run_package_build:
        description: "Build node agent package via make package"
        required: false
        default: false
        type: boolean
      run_lint:
        description: "Run lint via make lint"
        required: false
        default: false
        type: boolean
      run_test:
        description: "Run test via make test"
        required: false
        default: false
        type: boolean
      run_version_tag:
        description: "Run version tag"
        required: false
        default: true
        type: boolean
      run_docker_build:
        description: "Run docker build via make docker-build"
        required: false
        default: false
        type: boolean
      run_docker_push:
        description: "Run docker push via make docker-push"
        required: false
        default: false
        type: boolean
      run_helm_build:
        description: "Run helm build via make helm-build"
        required: false
        default: false
        type: boolean
      run_helm_push:
        description: "Run helm push via make helm-push"
        required: false
        default: false
        type: boolean
      run_artifact_push:
        description: "Push artifacts to Release Service fileserver"
        required: false
        default: false
        type: boolean
      artifact_to_s3:
        description: >-
          "Choose if the Release Service artifact will be pushed to S3. Default is false,
          meaning it will be an ECR artifact. Credentials will be configured based on it"
        required: false
        default: false
        type: boolean
      run_deb_push:
        description: "Run Debian push via make deb-push"
        required: false
        default: false
        type: boolean
      run_version_dev:
        description: "Run version dev"
        required: false
        default: false
        type: boolean
      prefix_tag_separator:
        description: >-
          If provided, the tag will be prefixed input.project_folder with this separator
        required: false
        default: ""
        type: string
      project_folder:
        description: >-
          Project subfolder where the job will run, defaults to '.'
        required: false
        default: "."
        type: string
      orch_ci_repo_ref:
        description: >-
          The ref of the orch-ci repo, including bootstrap action and scripts, defaults to 'main'
        required: false
        default: "main"
        type: string
      bootstrap_tools:
        description: >-
          "Comma-separated list of tools to install (e.g., 'go,docker') or 'all' for all tools"
        required: false
        default: "all"
        type: string
      cache_go:
        description: >-
          Should Go-related cache for project be saved/restored.
          The cache created by `pre-merge` is only available for current branch (i.e., not for other branches and not for `main`).
          However, the cache created by `main` is available for both `main` and all other branches.
          That's why it's good that caching was also enabled for `post-merge` and took into account the cache from all actions that could generate it
          (usually: `run_build`, `run_lint`, and `run_test`).
        required: false
        default: false
        type: boolean
      remove_cache_go:
        description: >-
          Should Go-related cache for project be removed when not needed anymore.
          It can be useful when there's not enough space on the runner, and all actions that create/use the cache have already been completed.
        required: false
        default: false
        type: boolean
      persist_creds:
        description: "deprecated. will be removed in the future"
        required: false
        default: false
        type: boolean
      runs_on:
        description: "Label for runner"
        required: false
        default: "ubuntu-latest"
        type: string
      trivy_config_path:
        description: "Path to trivy configuration file"
        required: false
        default: "trivy.yaml"
        type: string
      trivy_image_skip:
        description: "Images to skip scanning with trivy"
        required: false
        default: ""
        type: string
      run_ghcr_push:
        description: "Push artifacts to github container registry"
        required: false
        default: false
        type: boolean
    secrets:
      SYS_EMF_GH_TOKEN:
        required: false
      NO_AUTH_ECR_PUSH_USERNAME:
        required: false
      NO_AUTH_ECR_PUSH_PASSWD:
        required: false
      NO_AUTH_S3_PUSH_USERNAME:
        required: false
      NO_AUTH_S3_PUSH_PASSWD:
        required: false
      MSTEAMS_WEBHOOK:
        required: false
permissions:
  contents: read
jobs:
  sanitize-project-folder:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      sanitized_project_name: ${{ steps.sanitize.outputs.sanitized_project_name }}
    steps:
      - name: Sanitize project folder
        id: sanitize
        env:
          INPUTS_PROJECT_FOLDER: ${{ inputs.project_folder }}
        run: |
          # check if inputs.project_folder is set, if not return repository name
          if [ -z "${INPUTS_PROJECT_FOLDER}" ] || [ "${INPUTS_PROJECT_FOLDER}" = "." ]; then
            SANITIZED_PROJECT_NAME="${GITHUB_REPOSITORY#"${GITHUB_REPOSITORY_OWNER}/"}"
          else
            SANITIZED_PROJECT_NAME=$(echo "${INPUTS_PROJECT_FOLDER}" | tr '/' '-')
          fi

          echo "SANITIZED_PROJECT_NAME=${SANITIZED_PROJECT_NAME}" >> "$GITHUB_ENV"
          echo "sanitized_project_name=${SANITIZED_PROJECT_NAME}" >> "$GITHUB_OUTPUT"
  trivy-filesystem-scan:
    if: github.actor != 'dependabot[bot]'
    permissions:
      security-events: write
    runs-on: ubuntu-latest
    needs: sanitize-project-folder
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          persist-credentials: false
      - name: Run Trivy Filesystem Scan
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8  # 0.33.1
        with:
          scan-type: 'fs'
          scan-ref: ${{ inputs.project_folder }}
          format: 'sarif'
          severity: 'UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: true
          trivy-config: ${{ inputs.trivy_config_path }}
          scanners: 'vuln,secret'
          output: "trivy_scan_report-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif"
      - name: Tag Trivy SARIF results
        run: |
          jq '
            .runs |= map(
              .tool.driver.rules |= (. // [] | map(
                .properties |= (. // {} ) + { tags: ((.tags // []) + ["Trivy_fs"] | unique) }
              )) |
              .results |= (. // [] | map(
                .properties |= (. // {} ) + { tags: ((.tags // []) + ["Trivy_fs"] | unique) }
              ))
            )
          ' trivy_scan_report-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif \
          > trivy_tagged.sarif \
          && mv trivy_tagged.sarif trivy_scan_report-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif
      - name: Run Trivy SBOM
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8  # 0.33.1
        with:
          scan-type: 'fs'
          format: 'spdx-json'
          output: "trivy_scan_report-sbom-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.json"
      - name: Upload Trivy Scan Report
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: trivy-scan-report-sbom-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}
          path: trivy_scan_report-sbom-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.json
      - name: Upload Trivy Scan Report
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: trivy-fs-scan-report-fs-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}
          path: trivy_scan_report-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif
      - name: Upload Trivy Results
        uses: github/codeql-action/upload-sarif@45cbd0c69e560cd9e7cd7f8c32362050c9b7ded2  # v3.29.5
        with:
          sarif_file: trivy_scan_report-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif
          category: Trivy_fs
  trivy-config-scan:
    permissions:
      contents: read
      security-events: write
    runs-on: ubuntu-latest
    needs: sanitize-project-folder
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd
        with:
          persist-credentials: false

      - name: Run Trivy Config Scan (Dockerfile / IaC)
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8
        with:
          scan-type: 'config'
          scan-ref: ${{ inputs.project_folder }}
          format: 'sarif'
          severity: 'UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL'
          trivy-config: ${{ inputs.trivy_config_path }}
          output: trivy-config-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif
      - name: Tag Trivy SARIF results
        run: |
          jq '
            .runs |= map(
              .tool.driver.rules |= (. // [] | map(
                .properties |= (. // {} ) + { tags: ((.tags // []) + ["Trivy_config"] | unique) }
              )) |
              .results |= (. // [] | map(
                .properties |= (. // {} ) + { tags: ((.tags // []) + ["Trivy_config"] | unique) }
              ))
            )
          ' trivy-config-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif \
          > trivy_tagged.sarif \
          && mv trivy_tagged.sarif trivy-config-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif

      - name: Upload Trivy Config Scan Report (SDL419)
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f
        with:
          name: trivy-config-scan-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}
          path: trivy-config-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif

      - name: Upload Trivy Config Results to Security Tab
        uses: github/codeql-action/upload-sarif@45cbd0c69e560cd9e7cd7f8c32362050c9b7ded2
        with:
          sarif_file: trivy-config-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}.sarif
          category: Trivy_config
  zizmor-scan:
    permissions:
      security-events: write
    runs-on: ubuntu-latest
    needs: sanitize-project-folder
    env:
      ZIZMOR_VERSION: 1.20.0
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          persist-credentials: false

      - name: Install uv
        uses: astral-sh/setup-uv@eac588ad8def6316056a12d4907a9d4d84ff7a3b  # v7.3.0

      - name: Run zizmor
        run: uvx zizmor=="$ZIZMOR_VERSION" "$GITHUB_WORKSPACE" --format sarif > zizmor_scan_report.sarif

      - name: Upload Zizmor Results
        uses: github/codeql-action/upload-sarif@45cbd0c69e560cd9e7cd7f8c32362050c9b7ded2  # v3.29.5
        with:
          sarif_file: zizmor_scan_report.sarif
  bandit:
    permissions:
      security-events: write
    runs-on: ubuntu-latest
    needs: sanitize-project-folder
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          persist-credentials: false
      - name: Run Bandit scan
        uses: open-edge-platform/orch-ci/.github/actions/security/bandit@467367d6f859a4654f2645ca78efd60035cf390c  # 2026.0.8
        with:
          scan-scope: "all"
          fail-on-findings: false
  run-repo-pipelines:
    permissions:
      contents: read
    runs-on: ${{ inputs.runs_on }}
    needs: sanitize-project-folder
    outputs:
      images: ${{ steps.list-images.outputs.images }}
      ecr_images: ${{ steps.find-images.outputs.ecr_images }}
      binaries: ${{ steps.find-binaries.outputs.binaries }}
      artifact_name: ${{ steps.artifact-name.outputs.artifact_name }}
    env:
      GIT_SHORT_URL: ${{ github.repository }}
      PROJECT_NAME: ${{ github.repository }}
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          # Do not persist credentials by default, otherwise they
          # will clash with credentials set by bootstrap action
          persist-credentials: false
          # Fetch all history, otherwise sporadic issue with missing tags
          fetch-depth: 0
          # Fetch tags
          fetch-tags: true
          # Checkout the branch that triggered the workflow to avoid detached HEAD
          ref: ${{ github.head_ref }}

      - name: Checkout action repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          repository: open-edge-platform/orch-ci
          ref: ${{ inputs.orch_ci_repo_ref }}
          path: ci
          persist-credentials: false

      - name: Version Check
        if: ${{ inputs.run_version_check }}
        env:
          BASEDIR: ${{ inputs.project_folder }}
          PREFIX_TAG_SEPARATOR: ${{ inputs.prefix_tag_separator }}
        run: |
          if [ -n "${PREFIX_TAG_SEPARATOR}" ]; then
            ./ci/scripts/version-check.sh \
              "${BASEDIR}${PREFIX_TAG_SEPARATOR}"
          else
            ./ci/scripts/version-check.sh
          fi

      - name: Version Tag
        if: ${{ inputs.run_version_tag }}
        working-directory: ${{ inputs.project_folder }}
        env:
          GITHUB_TOKEN: ${{ secrets.SYS_EMF_GH_TOKEN }}
          PREFIX_TAG_SEPARATOR: ${{ inputs.prefix_tag_separator }}
          PROJECT_FOLDER: ${{ inputs.project_folder }}
        run: |
          set -eu -o pipefail
          if [ -n "${PREFIX_TAG_SEPARATOR}" ]; then
            "$GITHUB_WORKSPACE"/ci/scripts/version-tag-param.sh \
              "${PROJECT_FOLDER}${PREFIX_TAG_SEPARATOR}"
          else
            "$GITHUB_WORKSPACE"/ci/scripts/version-tag.sh
          fi

      - name: Bootstrap CI environment
        uses: ./ci/.github/actions/bootstrap
        with:
          bootstrap_tools: ${{ inputs.bootstrap_tools }}

      - name: Dep Version Check
        if: ${{ inputs.run_dep_version_check }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          echo "Verifying dependencies version"
          make dependency-check

      - name: Make sure directories where the cache will be restored exist and are empty
        if: ${{ inputs.cache_go }}
        run: |
          # Some caches from previous steps/jobs might be left, clean them up to avoid
          # "Cannot open: File exists" errors

          GOCACHE="$(go env GOCACHE)"
          GOMODCACHE="$(go env GOMODCACHE)"

          mkdir -p "${GOCACHE}" "${GOMODCACHE}" ~/.cache/golangci-lint

          echo "Cache sizes before removal:"
          sudo du -sh "${GOCACHE}"
          sudo du -sh "${GOMODCACHE}"
          sudo du -sh ~/.cache/golangci-lint

          sudo rm -rf "${GOCACHE:?}"/{*,.*} || true
          sudo rm -rf "${GOMODCACHE:?}"/{*,.*} || true
          sudo rm -rf ~/.cache/golangci-lint/{*,.*} || true

          echo "Cache sizes after removal:"
          sudo du -sh "${GOCACHE}"
          sudo du -sh "${GOMODCACHE}"
          sudo du -sh ~/.cache/golangci-lint

          echo "GOCACHE=$GOCACHE" >> "$GITHUB_ENV"
          echo "GOMODCACHE=$GOMODCACHE" >> "$GITHUB_ENV"

      - name: Restore Go cache
        if: ${{ inputs.cache_go }}
        id: restored-project-go-cache
        uses: actions/cache/restore@cdf6c1fa76f9f475f3d7449005a359c84ca0f306  # v5.0.3
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
            ~/.cache/golangci-lint
          key: ${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}-${{ runner.os }}-go-${{ env.GOLANG_VER }}-${{ hashFiles('**/go.mod') }}
          restore-keys: |
            ${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}-${{ runner.os }}-go-${{ env.GOLANG_VER }}-
            ${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}-${{ runner.os }}-go-

      - name: Free Ubuntu Disk Space
        if: ${{ inputs.run_freeup_ubuntu_space }}
        uses: jlumbroso/free-disk-space@54081f138730dfa15788a46383842cd2f914a1be  # v1.3.1
        with:
          android: true
          dotnet: true

      - name: Build Code
        if: ${{ inputs.run_build }}
        working-directory: ${{ inputs.project_folder }}
        shell: bash
        run: |
          echo "Building the code"
          make build

      - name: Build Package
        if: ${{ inputs.run_package_build }}
        working-directory: ${{ inputs.project_folder }}
        shell: bash
        run: |
          make package

      - name: Find binaries
        id: find-binaries
        shell: bash
        env:
          PROJECT_FOLDER: ${{ inputs.project_folder }}
        run: |
          set -euo pipefail
          echo "üîç Searching for binaries to sign..."
          directories=("out" "build" "bin")
          binaries=()
          for dir in "${directories[@]}"; do
            full_path="${PROJECT_FOLDER}/${dir}"
            echo "Checking path: $full_path"
            if [ -d "$full_path" ]; then
              while IFS= read -r file; do
                # Only include executable files, exclude .git and package metadata (e.g., DEBIAN folder)
                if [[ -x "$file" ]] \
                  && [[ "$file" != *"/DEBIAN/"* ]] \
                  && [[ "$file" != *"/.git/"* ]]; then
                  binaries+=("$file")
                fi
              done < <(find "$full_path" -type f ! -path '*/.git/*' || true)

            fi
          done

          unique_binaries=()
          seen_names=()
          for f in "${binaries[@]}"; do
            bn=$(basename "$f")
            if [[ ! " ${seen_names[*]} " =~ " $bn " ]]; then
              unique_binaries+=("$f")
              seen_names+=("$bn")
            fi
          done

          if [ ${#unique_binaries[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è No binaries found to sign."
            echo "binaries=[]" >> "$GITHUB_OUTPUT"
          else
            echo "Found binaries:"
            printf '%s\n' "${unique_binaries[@]}"

            # Convert array to JSON safely for GitHub Actions
            binaries_json=$(printf '%s\n' "${unique_binaries[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "binaries=${binaries_json}" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare artifact name
        id: artifact-name
        run: |
          binaries_json="${{ steps.find-binaries.outputs.binaries }}"
          artifact_hash=$(echo "$binaries_json" | sha1sum | awk '{print $1}')
          artifact_name="built-binaries-$artifact_hash"
          echo "artifact_name=$artifact_name" >> "$GITHUB_OUTPUT"

      - name: Copy binaries to temp folder
        if: ${{ steps.find-binaries.outputs.binaries != '[]' && steps.find-binaries.outputs.binaries != '[""]' }}
        run: |
          set -euo pipefail
          binaries_json='${{ steps.find-binaries.outputs.binaries }}'
          TEMP_DIR=$(mktemp -d)
          echo "Copying binaries to temporary folder: $TEMP_DIR"
          echo "$binaries_json" | jq -r '.[]' | while IFS= read -r bin; do
            mkdir -p "$TEMP_DIR/$(dirname "$bin")"
            cp -a "$bin" "$TEMP_DIR/$bin"
          done
          echo "All binaries copied to $TEMP_DIR"
          echo "TEMP_DIR=$TEMP_DIR" >> "$GITHUB_ENV"

      - name: Upload binaries artifact
        if: ${{ steps.find-binaries.outputs.binaries != '[]' && steps.find-binaries.outputs.binaries != '[""]' }}
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact-name.outputs.artifact_name }}
          path: ${{ env.TEMP_DIR }}
          if-no-files-found: ignore

      - name: Lint Code
        if: ${{ inputs.run_lint }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make lint

      - name: Test Code
        if: ${{ inputs.run_test }}
        working-directory: ${{ inputs.project_folder }}
        env:  ## temp workaround
          GITHUB_TOKEN: ${{ secrets.SYS_EMF_GH_TOKEN }}
        run: |
          make test

      - name: Save Go cache
        if: ${{ inputs.cache_go && steps.restored-project-go-cache.outputs.cache-hit != 'true' }}
        uses: actions/cache/save@cdf6c1fa76f9f475f3d7449005a359c84ca0f306  # v5.0.3
        with:
          path: |
            ${{ env.GOCACHE }}
            ${{ env.GOMODCACHE }}
            ~/.cache/golangci-lint
          key: ${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}-${{ runner.os }}-go-${{ env.GOLANG_VER }}-${{ hashFiles('**/go.mod') }}

      - name: Configure AWS credentials
        if: inputs.run_docker_push || inputs.run_helm_push || inputs.run_deb_push
        uses: aws-actions/configure-aws-credentials@8df5847569e6427dd6c4fb1cf565c83acfa8afa7  # v6.0.0
        with:
          aws-access-key-id: ${{ secrets.NO_AUTH_ECR_PUSH_USERNAME }}
          aws-secret-access-key: ${{ secrets.NO_AUTH_ECR_PUSH_PASSWD }}
          aws-region: us-west-2

      - name: Login to Amazon ECR
        if: inputs.run_docker_push || inputs.run_helm_push || inputs.run_deb_push
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076  # v2.0.1
        with:
          registries: "080137407410"

      - name: Remove Go-related cache when not needed anymore to free up space
        if: ${{ inputs.remove_cache_go }}
        run: |
          GOCACHE="$(go env GOCACHE)"
          GOMODCACHE="$(go env GOMODCACHE)"

          echo "Cache sizes before removal:"
          sudo du -sh "${GOCACHE}"
          sudo du -sh "${GOMODCACHE}"
          sudo du -sh ~/.cache/golangci-lint

          sudo rm -rf "${GOCACHE:?}"/{*,.*} || true
          sudo rm -rf "${GOMODCACHE:?}"/{*,.*} || true
          sudo rm -rf ~/.cache/golangci-lint/{*,.*} || true

          echo "Cache sizes after removal:"
          sudo du -sh "${GOCACHE}"
          sudo du -sh "${GOMODCACHE}"
          sudo du -sh ~/.cache/golangci-lint

      - name: Build Docker image
        if: ${{ inputs.run_docker_build }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make docker-build

      - name: Push Docker image
        if: ${{ inputs.run_docker_push }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make docker-push

      - name: List Docker Images
        id: list-images
        if: ${{ inputs.run_docker_build }}
        env:
          TRIVY_IMAGE_SKIP: ${{ inputs.trivy_image_skip }}
        run: |
          IFS=',' read -r -a skip_array <<< "${TRIVY_IMAGE_SKIP:-}"
          skip_patterns="(<none>|clamav|dependabot)"

          mapfile -t all_images < <(
            docker images --format "{{.Repository}}:{{.Tag}}" \
              | grep -Eiv "$skip_patterns" || true
          )
          filtered_images=()

          for image in "${all_images[@]}"; do
            skip=false
            for skip_image in "${skip_array[@]}"; do
              if [[ -n "$skip_image" && "$image" == "$skip_image" ]]; then
                skip=true
                break
              fi
            done

            if [ "$skip" = false ]; then
              filtered_images+=("$image")
            fi
          done

          images=$(printf '%s\n' "${filtered_images[@]}" | jq -R . | jq -s -c .)
          echo "images=$images" >> "$GITHUB_OUTPUT"

      - name: Save Docker Images
        if: ${{ inputs.run_docker_build }}
        env:
          IMAGES: ${{ steps.list-images.outputs.images }}
        run: |
          set -euo pipefail

          docker images
          mkdir -p docker-images
          mapfile -t formatted_images < <(echo "$IMAGES" | jq -r '.[]?')

          for image in "${formatted_images[@]}"; do
            docker save -o "docker-images/${image//[:\/]/_}.tar" "$image"
          done

      - name: Upload Docker Images
        if: ${{ inputs.run_docker_build }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: docker-images-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}
          path: docker-images

      - name: Find ECR images
        if: always()
        id: find-images
        shell: bash
        run: |
          set -euo pipefail
          echo "üîç Finding pushed ECR images to sign..."

          images=$(docker images --digests --format "{{.Repository}}@{{.Digest}}" \
            | grep '^080137407410.dkr.ecr.us-west-2.amazonaws.com' || true)

          images=$(echo "$images" | sed '/^\s*$/d' | sort -u)

          if [ -z "$images" ]; then
            echo "‚ö†Ô∏è No ECR images found to sign."
            echo "ecr_images=[]" >> $GITHUB_OUTPUT
          else
            ecr_images_json=$(printf '%s\n' "$images" | jq -R -s -c 'split("\n") | map(select(. != ""))')
            if [ -z "$ecr_images_json" ]; then
              ecr_images_json='[]'
            fi
            echo "Found images:"
            echo "$images"
            echo "ecr_images=${ecr_images_json}" >> $GITHUB_OUTPUT
          fi

      - name: Build Helm chart
        if: ${{ inputs.run_helm_build }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make helm-build

      - name: Push Helm chart
        if: ${{ inputs.run_helm_push }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make helm-push

      - name: Push Agent packages
        if: ${{ inputs.run_deb_push }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make deb-push

      # Configure AWS credentials for ECR
      - name: Configure AWS credentials for ECR
        if: ${{ !inputs.artifact_to_s3 && inputs.run_artifact_push }}
        uses: aws-actions/configure-aws-credentials@8df5847569e6427dd6c4fb1cf565c83acfa8afa7  # v6.0.0
        with:
          aws-access-key-id: ${{ secrets.NO_AUTH_ECR_PUSH_USERNAME }}
          aws-secret-access-key: ${{ secrets.NO_AUTH_ECR_PUSH_PASSWD }}
          aws-region: us-west-2

      # Configure AWS credentials for S3
      - name: Configure AWS credentials for S3
        if: ${{ inputs.artifact_to_s3 && inputs.run_artifact_push }}
        uses: aws-actions/configure-aws-credentials@8df5847569e6427dd6c4fb1cf565c83acfa8afa7  # v6.0.0
        with:
          aws-access-key-id: ${{ secrets.NO_AUTH_S3_PUSH_USERNAME }}
          aws-secret-access-key: ${{ secrets.NO_AUTH_S3_PUSH_PASSWD }}
          aws-region: us-west-2

      - name: Login to Amazon ECR
        if: ${{ !inputs.artifact_to_s3 && inputs.run_artifact_push }}
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076  # v2.0.1
        with:
          registries: "080137407410"

      - name: Upload artifacts to Release Service
        if: ${{ inputs.run_artifact_push }}
        working-directory: ${{ inputs.project_folder }}
        run: |
          make artifact-publish

      - name: Upload artifacts to ghcr.io
        if: ${{ inputs.run_ghcr_push }}
        working-directory: ${{ inputs.project_folder }}
        env:
          CR_PAT: ${{ secrets.SYS_EMF_GH_TOKEN }}
        run: |
          echo $CR_PAT | docker login ghcr.io -u github-bot@intel.com --password-stdin
          make ghcr-publish
          docker logout ghcr.io

  sign-binaries:
    permissions:
      id-token: write
      contents: read
    needs: run-repo-pipelines
    if: ${{ needs.run-repo-pipelines.outputs.binaries != '[]' && needs.run-repo-pipelines.outputs.binaries != '[""]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        binary: ${{ fromJSON(needs.run-repo-pipelines.outputs.binaries) }}
        _index: [0]  # ensures matrix uniqueness
    steps:
      - name: Checkout orch-ci for Cosign
        uses: actions/checkout@v6.0.2
        with:
          repository: open-edge-platform/orch-ci
          token: ${{ secrets.SYS_EMF_GH_TOKEN }}
          path: orch-ci
          persist-credentials: false
      - name: Download built binaries
        uses: actions/download-artifact@v7
        with:
          name: ${{ needs.run-repo-pipelines.outputs.artifact_name }}
          path: ./binaries
      - name: Resolve actual binary path
        id: resolve-path
        run: |
          set -euo pipefail
          ARTIFACT_ROOT="./binaries"
          BIN_NAME=$(basename "${{ matrix.binary }}")
          FILE_PATH=$(find "$ARTIFACT_ROOT" -type f -name "$BIN_NAME" | head -n1)
          if [ -z "$FILE_PATH" ]; then
            echo "Error: binary not found in artifact: $BIN_NAME"
            exit 1
          fi
          echo "binary_path=$FILE_PATH" >> "$GITHUB_OUTPUT"
          SANITIZED_BASENAME=$(echo "$BIN_NAME" | tr '/:' '_')
          PATH_HASH=$(echo -n "$FILE_PATH" | sha1sum | awk '{print $1}')
          SANITIZED_NAME="${SANITIZED_BASENAME}-${PATH_HASH:0:8}-${{ matrix._index }}"
          echo "sanitized_name=$SANITIZED_NAME" >> "$GITHUB_OUTPUT"

      - name: Sign binary with Cosign
        uses: ./orch-ci/.github/actions/security/cosign
        with:
          target: binary
          artifact: ${{ steps.resolve-path.outputs.binary_path }}
          environment: non-prod
          gh_token: ${{ secrets.SYS_EMF_GH_TOKEN }}

      - name: Prepare Cosign artifacts for upload
        shell: bash
        run: |
          mkdir -p ./cosign-artifacts
          mv cosign.* ./cosign-artifacts/
          echo "ART_NAME=${{ needs.run-repo-pipelines.outputs.artifact_name }}-${{ steps.resolve-path.outputs.sanitized_name }}" >> $GITHUB_ENV

      - name: Upload Cosign artifacts
        uses: actions/upload-artifact@v6
        with:
          name: ${{ env.ART_NAME }}
          path: ./cosign-artifacts
          if-no-files-found: error

  sign-images:
    permissions:
      id-token: write
      contents: read
    needs: run-repo-pipelines
    if: ${{ needs.run-repo-pipelines.outputs.ecr_images != '[]' && needs.run-repo-pipelines.outputs.ecr_images != '[""]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.run-repo-pipelines.outputs.ecr_images) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.2
        with:
          persist-credentials: false
      - name: Checkout orch-ci for Cosign
        uses: actions/checkout@v6.0.2
        with:
          repository: open-edge-platform/orch-ci
          token: ${{ secrets.SYS_EMF_GH_TOKEN }}
          path: orch-ci
          persist-credentials: false
      - name: Configure AWS credentials for ECR
        uses: aws-actions/configure-aws-credentials@v6
        with:
          aws-access-key-id: ${{ secrets.NO_AUTH_ECR_PUSH_USERNAME }}
          aws-secret-access-key: ${{ secrets.NO_AUTH_ECR_PUSH_PASSWD }}
          aws-region: us-west-2
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registries: "080137407410"
      - name: Sign image
        uses: ./orch-ci/.github/actions/security/cosign
        with:
          target: image
          artifact: ${{ matrix.image }}
          environment: prod
          gh_token: ${{ secrets.SYS_EMF_GH_TOKEN }}

  scan-images:
    permissions:
      security-events: write
    if: >
      github.actor != 'dependabot[bot]' &&
      inputs.run_docker_build &&
      needs.run-repo-pipelines.outputs.images != '[]' &&
      needs.run-repo-pipelines.outputs.images != '[""]'
    needs: [sanitize-project-folder, run-repo-pipelines]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.run-repo-pipelines.outputs.images) }}
    steps:
      - name: Download Docker Images
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v5.0.0
        with:
          name: docker-images-${{ needs.sanitize-project-folder.outputs.sanitized_project_name }}

      - name: Load Docker Images
        run: |
          for tar in *.tar; do
            docker load -i "$tar"
          done

      - name: Sanitize Image Name
        id: sanitize
        env:
          MATRIX_IMAGE: ${{ matrix.image }}
        run: |
          # Replace colon with underscore
          sanitized_image_name="${MATRIX_IMAGE}"
          sanitized_image_name="${sanitized_image_name//[:\/]/_}"
          echo "sanitized_image_name=$sanitized_image_name" >> "$GITHUB_ENV"

      - name: Scan Image
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8  # 0.33.1
        with:
          image-ref: ${{ matrix.image }}
          format: 'sarif'
          severity: 'UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL'
          output: "trivy-${{ env.sanitized_image_name }}.sarif"
          ignore-unfixed: true
          trivy-config: ${{ inputs.trivy_config_path }}
      - name: Tag Trivy SARIF results
        run: |
          jq '
            .runs |= map(
              .tool.driver.rules |= (. // [] | map(
                .properties |= (. // {} ) + { tags: ((.tags // []) + ["Trivy_image"] | unique) }
              )) |
              .results |= (. // [] | map(
                .properties |= (. // {} ) + { tags: ((.tags // []) + ["Trivy_image"] | unique) }
              ))
            )
          ' trivy-${{ env.sanitized_image_name }}.sarif \
          > trivy_tagged.sarif \
          && mv trivy_tagged.sarif trivy-image-${{ env.sanitized_image_name }}.sarif

      - name: Upload Trivy Image Results
        uses: github/codeql-action/upload-sarif@45cbd0c69e560cd9e7cd7f8c32362050c9b7ded2  # v3.29.5
        with:
          sarif_file: trivy-image-${{ env.sanitized_image_name }}.sarif
          category: Trivy_image
      - name: Upload Trivy Image Vulnerability Scan (SDL514)
        if: ${{ always() }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f
        with:
          name: trivy-image-vuln-${{ env.sanitized_image_name }}
          path: trivy-image-${{ env.sanitized_image_name }}.sarif
  version-bump:
    permissions:
      contents: read
    runs-on: ubuntu-latest
    if: ${{inputs.run_version_dev}}
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          persist-credentials: false
      - name: Checkout action repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          repository: open-edge-platform/orch-ci
          path: ci
          ref: ${{ inputs.orch_ci_repo_ref }}
          persist-credentials: false
      - name: Run Version Update Action
        uses: open-edge-platform/orch-ci/dev-version-update@467367d6f859a4654f2645ca78efd60035cf390c  # 2026.0.8
        with:
          github_token: ${{ secrets.SYS_EMF_GH_TOKEN }}
          project_folder: ${{ inputs.project_folder }}
  notify-teams:
    needs: [run-repo-pipelines]
    if: always() &&
      contains(needs.*.result, 'failure')
    uses: open-edge-platform/orch-ci/.github/workflows/notify-teams.yml@467367d6f859a4654f2645ca78efd60035cf390c  # 2026.0.8
    secrets:
      MSTEAMS_WEBHOOK: ${{ secrets.MSTEAMS_WEBHOOK }}
