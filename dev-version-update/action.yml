# SPDX-FileCopyrightText: (C) 2025 Intel Corporation
# SPDX-License-Identifier: Apache-2.0
---
name: Increment to Next -dev Version
description: Updates VERSION files to next dev version after a release

inputs:
  exclude_paths:
    description: "Comma-separated list of path patterns to exclude from search"
    required: false
    default: "*/node_modules/*,*/dist/*,*/build/*,*/vendor/*,*/bin/*,*/pkg/*,*/.git/*"
  github_token:
    required: true
    description: "GitHub token for creating pull request"
  project_folder:
    required: false
    description: "Optional project folder to limit the search for VERSION files"
    type: string
    default: "."

runs:
  using: "composite"
  steps:
    - name: Set up Git identity and log in
      shell: bash
      env:
        github_token: ${{ inputs.github_token }}
      run: |
        git config --global user.name "github-bot@intel.com"
        git config --global user.email "do-not-reply@intel.com"
        echo "${github_token}" | gh auth login --with-token
        git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n x-access-token:"$github_token" | base64)"

    - name: Find and update VERSION files
      id: update_versions
      env:
        EXCLUDE_PATHS: ${{ inputs.exclude_paths }}
        INPUTS_PROJECT_FOLDER: ${{ inputs.project_folder }}
      shell: bash
      run: |
        source ${{ github.workspace }}/ci/scripts/tagging-lib.sh

        CURRENT_DATE=$(date +%d-%m-%Y-%H%M%S%N | cut -c1-20)

        # Create a more specific branch name when project_folder is specified
        if [[ "${INPUTS_PROJECT_FOLDER}" != "." ]]; then
          # Sanitize project folder name for branch naming
          SANITIZED_PROJECT=$(echo "${INPUTS_PROJECT_FOLDER}" | tr '/' '-' | tr '[:upper:]' '[:lower:]')
          BRANCH_NAME="update-versions-${SANITIZED_PROJECT}-${CURRENT_DATE}"
        else
          BRANCH_NAME="update-versions-${CURRENT_DATE}"
        fi

        git checkout -b $BRANCH_NAME

        CHANGES_MADE=0

        IFS=',' read -ra EXCLUDE_PATHS <<< "${EXCLUDE_PATHS}"
        INPUTS_PROJECT_FOLDER=$(echo "${INPUTS_PROJECT_FOLDER}" | xargs)
        if [[ -z "${INPUTS_PROJECT_FOLDER}" ]]; then
          INPUTS_PROJECT_FOLDER="."
        fi

        # If project_folder is ".", search everywhere, else restrict to that folder/project
        if [[ "${INPUTS_PROJECT_FOLDER}" == "." ]]; then
          FIND_CMD="find . -name VERSION -type f"
        else
          if [[ ! -d "${INPUTS_PROJECT_FOLDER}" ]]; then
            echo "Project folder ${INPUTS_PROJECT_FOLDER} does not exist"
            exit 0
          fi
          FIND_CMD="find ${INPUTS_PROJECT_FOLDER} -name VERSION -type f -path \"${INPUTS_PROJECT_FOLDER}/*\""
        fi

        for EXCLUDE in "${EXCLUDE_PATHS[@]}"; do
          FIND_CMD="$FIND_CMD -not -path \"$EXCLUDE\""
        done

        echo "Executing: $FIND_CMD"

        for VERSION_PATH in $(eval $FIND_CMD 2>/dev/null || echo ""); do
          echo "Processing $VERSION_PATH"
          export VERSIONFILE="$VERSION_PATH"
          if [ "$VERSION_PATH" == "./ci/VERSION" ]; then
            # skip the ci folder VERSION file, should only update VERSION files for project
            continue
          fi

          RELEASE_VERSION=0
          read_version
          check_if_releaseversion

          if [ $RELEASE_VERSION -eq 1 ]; then
            NEXT_VERSION=$(get_next_version "$NEW_VERSION" "-dev")
            echo "Updating $VERSION_PATH from $NEW_VERSION to $NEXT_VERSION"

            # Check if .update-version.sh exists in the same directory and execute it
            VERSION_DIR=$(dirname "$VERSION_PATH")
            UPDATE_SCRIPT="$VERSION_DIR/.update-version.sh"

            if [ -f "$UPDATE_SCRIPT" ]; then
              echo "Found .update-version.sh in $VERSION_DIR, executing..."
              chmod +x "$UPDATE_SCRIPT"
              "$UPDATE_SCRIPT" "$NEXT_VERSION"
            fi

            echo "$NEXT_VERSION" > "$VERSION_PATH"
          fi
        done

        # Check the list of updated files and add each to the commit
        CHANGED_FILES=$(git status -s)
        for CHANGED_FILE in ${CHANGED_FILES}; do
          # Skip change type
          if [[ "${CHANGED_FILE}" == "D" ]] || [[ "${CHANGED_FILE}" == "M" ]] || [[ "${CHANGED_FILE}" == "??" ]]; then
            continue
          fi
          # Skip ci/VERSION if .gitignore for project_folder does not exclude it from status
          if [[ "${CHANGED_FILE}" == "ci" ]] || [[ "${CHANGED_FILE}" == "ci/" ]]; then
            continue
          fi
          git add ${file}
          CHANGES_MADE=1
        done

        if [ $CHANGES_MADE -eq 1 ]; then
          # Create a more descriptive commit message
          if [[ "${INPUTS_PROJECT_FOLDER}" != "." ]]; then
            git commit -m "Update VERSION files to next dev version for ${INPUTS_PROJECT_FOLDER}"
          else
            git commit -m "Update VERSION files to next dev version"
          fi

          echo "------------------------------------------------------"
          echo "Updated files:"
          git diff --name-only HEAD~1 HEAD | while read file; do
            echo "- $file"
          done
          echo "------------------------------------------------------"

          git push origin $BRANCH_NAME

          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "changes_made=true" >> $GITHUB_OUTPUT
        else
          echo "No VERSION files found to update in ${INPUTS_PROJECT_FOLDER}"
          echo "changes_made=false" >> $GITHUB_OUTPUT
        fi

    - name: Create Pull Request
      if: steps.update_versions.outputs.changes_made == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.gh_token }}
        BRANCH_NAME: ${{ steps.update_versions.outputs.branch_name }}
        INPUTS_PROJECT_FOLDER: ${{ inputs.project_folder }}
      run: |
        TITLE="Version bump to -dev"
        INPUTS_PROJECT_FOLDER=$(echo "${INPUTS_PROJECT_FOLDER}" | xargs)
        if [[ -n "${INPUTS_PROJECT_FOLDER}" && "${INPUTS_PROJECT_FOLDER}" != "." ]]; then
          TITLE="${TITLE} for ${INPUTS_PROJECT_FOLDER}"
        fi

        gh pr create \
          --title "${TITLE}" \
          --body "Automatically bumping the version to the next development iteration (-dev suffix)." \
          --base main \
          --head ${BRANCH_NAME}
